---
layout: post
title:  红黑树
category: 技术基础
tags: 平衡术插入
description: 红黑树
---


因为BST(二叉搜索树)树操作之后会造成不同程度的倾斜。由此在BST的基础上产生了红黑树。

有如下性质


#### 定义
    
    
    
    性质1.节点是红色或黑色。
    性质2.根节点是黑色。
    性质3 每个叶节点（NIL节点，空节点）是黑色的。
    性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
    性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
    
    
    
#### 插入节点


新插入节点为红色。
如果父节点为红色，需要扭转保持平衡

在jdk中使用红黑是的场景就是TreeMap

下面是红黑树的对于节点p的左旋，右旋。以及节点P插入之后的着色。保持红黑树的平衡。

 TreeMap的红黑树

 
    
    //右旋的过程是将x (节点P)的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。
    
      /** From CLR */
    private void rotateRight(Entry<K,V> p) {
        if (p != null) {
             // p节点的左子树
            Entry<K,V> l = p.left;
            // p 的左子树指向l的右子树
            p.left = l.right;
            // 更新父节点
            if (l.right != null) l.right.parent = p;
            l.parent = p.parent;
             //更新root 节点
            if (p.parent == null)
                root = l;
            // 更新p的父节点。    
            else if (p.parent.right == p)
                p.parent.right = l;
            else p.parent.left = l;
            l.right = p;
            p.parent = l;
        }
    }
    

![image](http://7x00ae.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E6%97%8B.jpg)
    
    


    //左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲。旋转之后，二叉查找树的属性仍然满足。
    
      /** From CLR */
    private void rotateLeft(Entry<K,V> p) {
        if (p != null) {
            // p的右节点
            Entry<K,V> r = p.right;
            //p的右边节点指向右节点的左节点
            p.right = r.left;
            //更新parent
            if (r.left != null)
                r.left.parent = p;
            r.parent = p.parent;
            if (p.parent == null)
                root = r;
            // 更新p父节点指向子节点的引用    
            else if (p.parent.left == p)
                p.parent.left = r;
            else
                p.parent.right = r;
            r.left = p;
            p.parent = r;
        }
    }
    



![image](http://7x00ae.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E6%97%8B.jpg)







    
           /** From CLR */
     // 当插入节点x 的时候需要保持红黑树的平衡
    private void fixAfterInsertion(Entry<K,V> x) {
       // 插入的节点置为红色(为什么)
        x.color = RED;
        // 如果 x节点不为空，不为root节点且父节点的颜色为红色就需要一直调整
        
        while (x != null && x != root && x.parent.color == RED) {
             // 如果x的父节点 是x 祖先节点的左孩子
            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            
               // 取x祖先节点的右孩子 叔叔节点 y      
                Entry<K,V> y = rightOf(parentOf(parentOf(x)));
        
                // 如果叔叔 节点为红色,吧x的父节点和叔叔节点设置为黑色。
                // 把祖先节点设置为红色。
                if (colorOf(y) == RED) {
                    //如果叔叔节点为红色 case1.
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                // 如果叔叔 节点为黑色，设置父节点为黑色，祖先节点为红色。然后右边旋转。
                    
                    // 如果x 是左孩子。需要左旋转。
                    if (x == rightOf(parentOf(x))) {
                       //如果新节点，父节点，祖先节点 不在同一个直线上 case3
                        x = parentOf(x);
                        rotateLeft(x);
                    }
                    // 
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateRight(parentOf(parentOf(x)));
                }
                //如果x的父节点 是x 祖先节点的右边孩子
            } else {
               // 获取叔叔节点y。
                Entry<K,V> y = leftOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                  //如果叔叔节点为红色 case1.
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == leftOf(parentOf(x))) {
                      //如果新节点，父节点，祖先节点 不在同一个直线上 case3
                        x = parentOf(x);
                        rotateRight(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateLeft(parentOf(parentOf(x)));
                }
            }
        }
        root.color = BLACK;
    }
        

根据以上代码

插入修复操作分为以下的三种情况，而且新插入的节点的父节点都是红色的：

1. 叔叔节点也为红色。
2. 叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上。
3. 叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上。
4. 


##### case1

如果叔叔节点为红色, 把x的父节点这是为黑色， 叔叔节点也设置为黑色，祖先节点设置为红色。
x 指向祖先节点，继续where循环知道x的父节点为黑色。

##### case2

新节点 。父节点，祖先节点在同一个直线上。（根据是在左边还是右边）直接设置新节点父亲节点为黑色，祖先节点为红色。然后左旋转 祖先节点。

##### case3
新节点 。父节点，祖先节点在同不在同一个直线上，（根据是在左边还是右边）

旋转新节点的父节点。然后执行case2.


#### 总结

因为二叉搜索树在多次插入节点，变化之后可能会造成不同程度的倾斜，所以就有了红黑树，根据颜色特性来保持平衡。
红黑树插入一个节点后，应该把当前节点置为红色，因为红黑树的第五条性质，这样保持红黑树平衡性的条件就多了一条。
红黑树插入一个节点之后，如果父节点为红色就一定要调整主要有三种情况
1. 叔叔节点为红色。
2. 叔叔节点不为红色。且新节点，父节点，祖先节点在同一个直线上。
3. 叔叔节点不为红色。且新节点，父节点，祖先节点不在同一个直线上。







