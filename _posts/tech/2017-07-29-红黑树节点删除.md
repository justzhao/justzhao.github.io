---
layout: post
title:  红黑树节点删除
category: 技术基础
tags: 红黑树节点删除
description: 红黑树
---
红黑树只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。

红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。任何不平衡都会在三次旋转之内解决。


#### 红黑树的删除

红黑树的删除分为两个步骤：

1. 找到待删除的节点,当作一颗二叉查找树，将该节点从二叉查找树中删除
2. 修正红黑树的颜色，满足红黑树的性质:旋转和重新着色。


具体操作如下



第一步：
删除常规二叉查找树中删除节点的方法是一样的"。分3种情况：

-  被删除节点没有孩子，即为叶节点。那么，直接将该节点删除就OK了。

-  被删除节点只有一个孩子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。
 
-  被删除节点有两个孩子。先找出它的后继节点,把后继节点的内容复制给要删除的节点，此时需要删除后继节点。 为什么要这样操作，设想待删除的节点p有两个孩子，找到后继节点s。 s的内容复制给p，然后删除s，此时s必定没有孩子或者有且只有一个孩子，此时转为 case1,case2了。

第二步：旋转和着色，使红黑树重新满足性质。

下面是treeMap删除节点的过程


        
    /**
     * Delete node p, and then rebalance the tree.
     */
     public V remove(Object key) {
        Entry<K,V> p = getEntry(key);
        if (p == null)
            return null;

        V oldValue = p.value;
        deleteEntry(p);
        return oldValue;
    }
    
    
    
    /**
     * Delete node p, and then rebalance the tree.
     */
    private void deleteEntry(Entry<K,V> p) {
        modCount++;
        size--;

         // 如果P有2个孩子，就找到p的后继节点s。并且把s复制给p。
         // 然后把P指向p的后继，此时待删除的节点是p的后继。
        if (p.left != null && p.right != null) {
            // case3                      
            Entry<K,V> s = successor(p);
            p.key = s.key;
            p.value = s.value;
            p = s;
        } // p has 2 children

    
        
        // replacement 节点为带删除节点左孩子，做孩子为空的时候，为右孩子
        // 转化为case2 ，或者case1
        Entry<K,V> replacement = (p.left != null ? p.left : p.right);

        //  如果待删除节点有孩子，就直接删除该节点，并且把修正父亲节点和孩子节点的指针。
        if (replacement != null) {
            // Link replacement to parent
            replacement.parent = p.parent;
            if (p.parent == null)
                root = replacement;
            else if (p == p.parent.left)
                p.parent.left  = replacement;
            else
                p.parent.right = replacement;

            // 删除
            p.left = p.right = p.parent = null;

          // 如果删除的节点为黑色，需要调整颜色。 
            if (p.color == BLACK)
                fixAfterDeletion(replacement);
        } else if (p.parent == null) { 
            // 表示要删除当前节点，且当前节点是根节点
            root = null;
        } else { 
          // 删除当前节点，如果当前节点为黑色，需要修正红黑树属性。
            if (p.color == BLACK)
                fixAfterDeletion(p);

            if (p.parent != null) {
                if (p == p.parent.left)
                    p.parent.left = null;
                else if (p == p.parent.right)
                    p.parent.right = null;
                p.parent = null;
            }
        }
    }

    // 修正红黑树的颜色。
    private void fixAfterDeletion(Entry<K,V> x) {
        // 如果x的节点不为根节点，且x的节点为黑色。需要一直调整。
        while (x != root && colorOf(x) == BLACK) {
            // 如果x是其父节点的左孩子
            if (x == leftOf(parentOf(x))) {
                Entry<K,V> sib = rightOf(parentOf(x));
                 
                // 如果兄弟节点为红色。  
                if (colorOf(sib) == RED) {
                    setColor(sib, BLACK);
                    setColor(parentOf(x), RED);
                    rotateLeft(parentOf(x));
                    sib = rightOf(parentOf(x));
                }

                if (colorOf(leftOf(sib))  == BLACK &&
                    colorOf(rightOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } else {
                    if (colorOf(rightOf(sib)) == BLACK) {
                        setColor(leftOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateRight(sib);
                        sib = rightOf(parentOf(x));
                    }
                    setColor(sib, colorOf(parentOf(x)));
                    setColor(parentOf(x), BLACK);
                    setColor(rightOf(sib), BLACK);
                    rotateLeft(parentOf(x));
                    x = root;
                }
            } else { // 如果x节点是父节点的右孩子。
                // 取兄弟节点
                Entry<K,V> sib = leftOf(parentOf(x));

                // 如果兄弟节点为红色，就把兄弟节点设置为黑色。
                //并且把父节点设置为红色。
                // 右旋父亲节点。并且更新兄弟节点的引用
                
                // case1 
                if (colorOf(sib) == RED) {
                    setColor(sib, BLACK);
                    setColor(parentOf(x), RED);
                    rotateRight(parentOf(x));
                    sib = leftOf(parentOf(x));
                }

                //如果兄弟节点右孩子的颜色等于黑色 ，左孩子等于黑色。兄弟节点设置为红色。
                // 然后x 设置为x的父节点，继续下一轮，。
                // case2
                if (colorOf(rightOf(sib)) == BLACK &&
                    colorOf(leftOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } else {
                // 相反，如果兄弟节点的做孩子为黑色。
                // 把兄弟节点的的右孩子设置为黑色，系统几点设置为红色。
                // 然后把兄弟节点左旋，更新兄弟节点的引用
                // case3 
                    if (colorOf(leftOf(sib)) == BLACK) {
                        setColor(rightOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateLeft(sib);
                        sib = leftOf(parentOf(x));
                    }
                    
                    // case4
                    // 设置兄弟节点的颜色和父节点颜色一样
                    setColor(sib, colorOf(parentOf(x)));
                    //设置父节点为黑色。
                    setColor(parentOf(x), BLACK);
                    // 设置兄弟节点左孩子为黑色。
                    setColor(leftOf(sib), BLACK);
                    // 右旋转父亲节点
                    rotateRight(parentOf(x));
                    x = root;
                }
            }
        }

        setColor(x, BLACK);
    }

    
 以下case都是在基于待删除节点为父节点的 右孩子情况下。   

##### case 1待删除的节点的兄弟节点是红色。
    
    此时把兄弟节点设置黑色。右旋转父节点，并且设置为红色
    
##### case 2待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。
    
    此时吧兄弟节点设置为红色，并且把 待调整节点指向 父节点，然后继续调整
    
##### case 3待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。

    设置兄弟节点的右孩子为黑色。设置兄弟节点为红色，然后左旋转兄弟节点。此时会转化为case4.

##### case 4待调整的节点的兄弟节点是黑色的节点，且兄弟节点的右子节点是红色的，左节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边，就是兄弟节点的左节点是红色，有节点为黑色。 
    设置兄弟节点和父亲节点颜色一样。设置父节点颜色为黑色，谁知兄弟节点左孩子为黑色，右旋转待调整节点的的父亲节点。



#### 总结

红黑树的删除节点和二叉查找树一样，先找到删除的节点，然后调整颜色，调整完颜色之后，删除节点。
