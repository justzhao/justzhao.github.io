---
layout: post
title: 重排序happens-before
category: 技术基础
tags:  重排序，内存模型，hanppens-before
description: 重排序，内存模型，hanppens-before
---


#### 简介

学习《Java 并发编程的艺术》 一书。

在第三章主要是关于内存模型的知识。

#### JVM 内存模型
Java 多线程之间的通信有JMM(Java 内存模型)控制，JMM定义了一个线程操作对共享变量操作何时对另外的线程可见。
共享变量存储在堆内存的主内存中，每个线程都有自己的本地内存，线程的本地内存都保存着主内存中共享变量的拷贝。
当一个线程需要操作某个共享变量时候，需要从主内存拷贝的本地内存，操作完之后在写回主内存。

在这里本地内存只是JMM的抽象概念，它可以包括线程的缓存，寄存器，写缓冲区和硬件。

如图来自书上
![image](http://7x00ae.com1.z0.glb.clouddn.com/java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg)


如图线程A 和线程B 的本地内存中都保存着主内存的某个共享变量的副本，可以发现如果线程A对共享变量X进行操作后，写回主存，这时候线程B必须重新从主内存中加载最新的共享变量x，否则会出现数据不一致的现象。

这里我们可以看到 对线程A的共享变量的操作并不会对线程B的可见。


#### 指令重排序

JVM在执行程序，为了提供性能，编译器和处理器会对指令进行重排序。

- 编译器优化的重排序，在不改变程序结果的前提下进行重排序
- 指令集别的重排序，处理器采用指令并行技术执行，如果不存在数据依赖性，就可以进行重排序
- 内存系统的重排序，由于处理器使用缓存和缓冲区，这时候可能出现乱序指令。
- 
![image](http://7x00ae.com1.z0.glb.clouddn.com/jvm%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F.jpg)

如下代码

    // 在线程A 执行
    int a=1; // A1
    int x=b; // A2    

    // 在线程B 执行
    int b=2;// B1
    int y=a;// B2 

    因为存在指令重排序 ，所以存在B2在B1前执行，A2在A1 前执行，有可能得到最终的结果为
    x=y=0    
    
    
JVM 可以在生成指令的特定位置插入内存屏障来禁止指令重排序。
![image](http://7x00ae.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E5%BA%8F.jpg)
    
#### happens-before 

happens-before原则。

阐述如下：

    在Java虚拟机中，使用JSR-133 内存模型，Java内存模型使用happens-before 来描述操作之间的可见性，
    在JVM中，如果一个操作的执行结果对另外一个操作可见，这两个操作之间必须存在happens-before 关系。




happens-before 原则有如下四种

- 程序顺序规则：一个线程中的每个操作happens-before 该线程后面的任意操作
- 监视锁规则: 对于一个锁的解锁，happens-before 随后的加锁
- volatile变量规则 ： 对一个volatile变量的写happens-before 后续对此变量的读。
- 传递性


happens-before 原则会禁止编译器和处理器的指令重排序。（还有内存重排序）

    需要注意的两个操作具有happens-before 关系，并不意味着第一个操作必须要在后一个操作之前执行，仅要求前一个操作的结果对后一个操作的结果可见。

##### as-if-serial

不管怎么重排序，在单线程内执行结果不能被改变。

为了遵守as-if-serial ，编译器和处理器不会对存在数据依赖性的操作做重排序，因为会改变程序执行结果。
如果操作之间不存在依赖性，重排序之后不影响程序结果，这些操作就会被编译器和处理器重排序。

    double pi=3.14 //A
    double i=1.0 //B
    double s=pi * r * r //C
    
如上代码 ABC 在单线程中执行， AB之间不存在依赖性，但是AC，BC之间存在依赖性，这时候AB执行顺序有可能被重排序如下:

    B===>A===>C
    
根据  happens-before 的程序法则，上述操作存在3个happens-before 关系

    A happens-before B
    B happens-before c
    A happens-before c （传递性）
    

在这里   A happens-before B ，但是存在B在A 之前执行的可能性，这是因为AB之间不存在数据依赖性。

A happens-before B  ，JMM 并不会要求A一定在B之前执行，而是要求A操作的结果对B操作的结果可见，且A操作排在B操作之前。
但是这里 AB之间不存在数据依赖性，也就是说A的操作结果不需要对B可见，AB重排序之后的结果和按照happens-before原则执行的结果一致。这样JMM允许这样的重排序.


##### 单线程内没有数据依赖的操作可以被JVM重排序


在多线程类，没有数据依赖的操作重排序可能会影响整体操作结果

如下代码
    
    int a=0;
    boolea flag=false;
    
    //线程A write操作
    a=1; //A
    flag=true; //B
    
    //线程B read操作
    if(flag){   //C
        int i=a * a;// D
    }
    
在上述代码中，AB 中不存在数据依赖性，可能被重排序 B A。    

当B线程执行时,此时B先执行，flag=true, 但是a=0;得到i=0;

因为重排序，造成了多线程执行结果被改变了。

#### 总结

在上面的代码中，操作C D存在控制依赖，当代码中存在控制依赖，会影响到指令序列执行的并行度，此时编译器和处理器会采用猜测执行来控制依赖
对指令并行度的影响。
比如线程B可能会提前计操作D，结算结果保存到缓存中，当操作C 为真的时候，把计算结果写入变量i。

单线程中，对存在控制依赖的语句进行重排序，不影响执行结果，但是在多线程中，就有可能影响到执行的结果。

