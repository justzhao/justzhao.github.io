---
layout: post
title: Java CPU Cache
category: 技术基础
tags: Java CPU Cache  
description:  CPU 缓存

---

#### 简介

在现代计算机中，所有的计算都需要CPU来完成，而CPU在计算的时候都需要访问内存，大多数的情况上，CPU并不会直接从
内存中获取数据，而是通过层层的缓存来进行。
CPU的计算频率越来越高，但是内存的访问速度却是效率很低。为了重复利用CPU的计算能力，提高CPU的吞吐量。
在CPU和内存之间开始引入了Cache L1（一级缓存） 。随后又有了Cache L2(二级缓存) ,Cache L3(三级缓存)

现代操作系统中一个处理器包含多个核，一个处理器间的多核共享L3 Cache。一个核包含寄存器、L1 Cache、L2 Cache

一个CPU中所有的核共享 Cache L3。

这时候只有Cache L3 才和内存通讯

#### CPU Cache

缓存是分“段”（line）的，一个段对应一块存储空间，大小是32（较早的ARM、90年代/2000年代早期的x86和PowerPC）、64（较新的ARM和x86）或128（较新的Power ISA机器）字节。每个缓存段知道自己对应什么范围的物理内存地址。

常用的CPU 的Cache Line一般都是64 个字节.

CPU cache 是示意图如下所示
![image](http://7x00ae.com1.z0.glb.clouddn.com/cpu%20cache.png)

同一个cpu的内核是共享CacheL3的。

当cpu接收到读内存的指令的时候，会把内存地址传递给Cache L1, Cache L1 会检查是否有这个内存地址对应的缓存端，如果没有，就会把整个缓存段从主存，或者更高级的缓存加载进来，因为cpu如果需要某个内存地址的数据，可能马上需要访问相邻地址的数据。

#### CPU Cache的操作

##### 读操作

在任意时刻，任意级别缓存中的缓存段的内容，等同于它对应的内存中的内容。

所以如果读Cache操作，就等同于读内存。


##### 写操作
    

CPU Cache有两种基本的写模式：

- 直写（write-through

 如果修改了本级缓存，直接把数据写到下一级缓存（或直接到内存）中，如果对应的段被缓存了，我们同时更新缓存中的内容（甚至直接丢弃）

- 回写（write-back）  
    
    缓存不会立即把写操作传递到下一级，而是仅修改本级缓存中的数据，并且把对应的缓存段标记为“脏”段。脏段会触发回写，也就是把里面的内容写到对应的内存或下一级缓存中。回写后，脏段又变“干净”了。当一个脏段被丢弃的时候，总是先要进行一次回写。

    当所有的脏段被回写后，任意级别缓存中的缓存段的内容，等同于它对应的内存中的内容。




#### 缓存一致性

现代计算机系统中，一个CPU常有多个核，每个核都会有自己的缓存段。当一份数据被多个缓存端缓存的时候，如果发生了修改就会有缓存一致性的问题。


内存传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线：缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（arbitrate）：同一个指令周期中，只有一个缓存可以读写内存。

当一个缓存代表它所属的处理器去读写内存时，其他处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一写内存，其他处理器马上就知道这块内存在它们自己的缓存中对应的段已经失效。


直写模式，一旦某个缓存段被修改，他的结果马上会被公布出去，其他核会马上更新自己的缓存

如果在回写模式中，不会马上公布出去，可能在指令执行很久之后，数据才会真正的回写到内存中。



由此引入了MESI(Modified、Exclusive、Shared、Invalid)协议

##### MESI 协议


- 已修改（Modified）缓存段，属于脏段，它们已经被所属的处理器修改了。如果一个段处于已修改状态，那么它在其他处理器缓存中的拷贝马上会变成失效状态，这个规律和E状态一样。此外，已修改缓存段如果被丢弃或标记为失效，那么先要把它的内容回写到内存中——这和回写模式下常规的脏段处理方式一样。



- 独占（Exclusive）缓存段，和S状态一样，也是和主内存内容保持一致的一份拷贝。区别在于，如果一个处理器持有了某个E状态的缓存段，那其他处理器就不能同时持有它，所以叫“独占”。这意味着，如果其他处理器原本也持有同一缓存段，那么它会马上变成“失效”状态

- 共享（Shared）缓存段，它是和主内存内容保持一致的一份拷贝，在这种状态下的缓存段只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存段，这就是名称的由来

- 失效（Invalid）缓存段，要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。

##### 伪共享

一旦CPU访问的数据不在Cache中，会加载相关内存地址相邻的数据。

如下例子，x y都是长度为16的数据

    public int add(int x[],int y[]){
    
        int sum=0;
        for(itn i=0;i<16;i++){
            sum +=x[i]*y[i];
        }
        return sum;
    }


cpu cache 会一次性加载x 数组和 y数组进来

在单线程中会一直在寄存器中运算，很快。

但是在多线程中会发生：伪共享的问题。


![image](http://7x00ae.com1.z0.glb.clouddn.com/%E4%BC%AA%E5%85%B1%E4%BA%AB.png)



数据X、Y、Z被加载到同一CacheLine中，线程A在Core1修改X，线程B在Core2上修改Y。根据MESI，假设是Core1是第一个发起操作的CPU核，Core1上的L1CacheLine由S（共享）状态变成M（修改，脏
数据）状态，然后告知其他的CPU核，图例则是Core2，引用同一地址的Cache Line已经无效了；
当Core2发起写操作时，首先导致Core1将X写回主存，CacheLine状态由M变为I（无效），而后才是Core2从主存重新读取该地址内容，Cache Line状态由I变成E（独占），最后进行修改Y操作， 
Cache Line从E变成M。可见多个线程操作在同一Cache Line上的不同数据，相互竞争同一Cache Line，导致线程彼此牵制影响，变成了串行程序，降低了并发性。此时我们则需要将共享在多线程间的数据进行隔离，使他们不在同一个Cache Line上，从而提升多线程的性能。


##### 解决Cache Line伪共享

- 填充cache line

    将该对象属性分组，将一起变化的放在一组，与其他属性无关的属性放到一组，将不变的属性放到一组。这样当每次对象变化时，不会带动所有的属性重新加载缓存，提升了读取效率。
    
    如下所示
    
    
    public class Myclass{
    
        long a1,a2,a3,a4,a5,a6,a7,a8;//填充一个Cache line
        int time;
        
        long b1,b2,b3,b4,b5,b6,b7,b8;/填充一个Cache line
        String name;
        long c1,c2,c3,c4,c5,c6,c7,c8;
    
    }

通过填充变量，使相关变量分开。


-  Contended 注解方式

JDK1.8中，新增了一种注解@sun.misc.Contended，来使各个变量在Cache line中分隔开。注意，jvm需要添加参数-XX:-RestrictContended才能开启此功能

     public class Myclass{
    
        @sun.msic.Contended("group1")
        int time;
        @sun.msic.Contended("group2")
        String name;
    }

使用了这个注解之后，
time和name就会在不同的cache line中。这样就不会尝试伪共享的问题。


在JDK 1.8 中，ConcurrentHashMap 和Thread 类就使用了这个注解。

#### 总结

本文介绍了现代计算机中CPU 的缓存概念和存在的问题，了解了Java中多线程会存在伪共享的问题和解决方式。




